
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><!-- InstanceBegin template="/Templates/designTemplate.dwt" codeOutsideHTMLIsLocked="false" -->
<head>
<style type="text/css">
  .centeredImage
    {
    text-align:center;
    margin-top:0px;
    margin-bottom:0px;
    padding:0px;
    }
</style>

<meta name="keywords" content="">

<meta name="description" content="">

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<!-- InstanceBeginEditable name="doctitle" -->
<title>Rodrigo Araújo ::: Software Engineer / Computer Scientist</title>


<!-- InstanceEndEditable -->

<link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
<link href="../../../../../css/stylesheet.css" rel="stylesheet" type="text/css" />
<link rel="stylesheet" href="../../../../../css/styles/github.css">
<script src="../../../../../highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script><!--[if IE]>

<style type="text/css"> 
/* place css fixes for all versions of IE in this conditional comment */
.twoColHybRtHdr #sidebar1 { padding-top: 30px; }
.twoColHybRtHdr #mainContent { zoom: 1; padding-top: 15px; }
/* the above proprietary zoom property gives IE the hasLayout it may need to avoid several bugs */
</style>
<![endif]-->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>

</head>

<body class="twoColHybRtHdr">
        <div class="sidebar" style="height:100%;">
<div id="container"><!-- InstanceBeginEditable name="headerNav" -->
  <div id="header" style='margin-top:-30px;padding-bottom:25px;'>
    
      <tr>
        <h1><a href="../../../../../index.html">Rodrigo Araújo</a></h1>
      </tr>
        <h4>Software Engineer & Computer Scientist</h4>

    
    <tr>
    </tr>
    <tr>
      <h3 style="padding-top:10px; margin-left:2px;">
        <!--<a href="./HomePage.html"><img src="./images/back.png" width="15"></a>
              <tr>
        <td>&nbsp;</td>
      </tr><-->

        <a href="/blog/" onclick="">BLOG    &nbsp;&nbsp;</a> 
        <a href="/about/">ABOUT    &nbsp;&nbsp;</a>
        <a href="/work/">WORK    &nbsp;&nbsp;</a>
        <a href="/contact/">CONTACT    &nbsp;&nbsp;</a>
      </h3>
    </tr>
    
    <!-- end #header -->
  </div>
  
  <div style="width:390px; margin-top:0px;" id="sidebar">
       <ul>
               <hr/>
          <li style="font-size:22px;"><a href="/archives/">Archives</a></li>
          <hr/>
      </ul>
</div>  

  <div style="margin-left:180px;margin-top:-158px;" id="mainContent" class="hidden">
    
    <ul>
  
    <li>
	<h1>
      <a href="/2015/01/06/Why-How-and-Where-To-Learn-Design-Patterns/">
	
	<div style="line-height:35px;color:#444;">Why, how and where to Learn Design Patterns</div>
	
	</a>
	</h1>
	<div style="margin-top:-15px;color:#E11F00;">6 January 2015</div>
        &nbsp;
      <p><html>

<p>The first thought I had when I started to study <a href="http://en.wikipedia.org/wiki/Software_design_pattern">Design Patterns</a> was:</p>

<p><em>- “damn, is all this really necessary?”</em></p>

<p>I mean, so many patterns, so many details to do things that look simple to do without any further detailed thoughts. And I started to question myself if this was really a productive thing.</p>

<p>The first answer I gave was:</p>


<p><em>-”no, *wonderful not-bad-word* this, I’m losing too much time trying to wrap my head around this”</em></p>

<p>So I forgot it and kept developing my software using something like <a href="https://gist.github.com/banaslee/4147370#file-xgh-en-txt">Extreme Go Horse</a>. (i was younger at that time)</p>

<p>Then, I saw a pattern being formed:</p>

<p><strong>Every time I came back to my old codes I couldn’t extend nor debbug it in a easy way. It was always extremely hard to work on it.</strong></p>

<p>And then I realized why: <strong>lack of good architectural decisions.</strong></p>

<p>So I decided to give another chance to learning Design Patterns and finally I understood its beauty.</p>
&nbsp;

<h2>Few things to keep in mind:</h2>

<p>1. It’s not about trying to fit every problem in every Design Pattern. That’s just a waste of time</p>
<p>2. It may be not very productive at start, the process of applying a DP in a determined problem takes time.</p>
<p>3. On the other hand, it will be extremely productive when you try to debug your code or try to extend it. Everything starts to make more sense and it’s way easier to change things when you’ve followed some patterns</p>
<p>4. When studying a Design Pattern, try hard to implement that solution in a problem. This will make total difference</p>

&nbsp;

<h2>Now, to the materials!</h2>

<p>Start with the classics:</p>

<h3><a href="http://www.amazon.com/Design-Patterns-Object-Oriented-Professional-Computing/dp/0201634988">Design Patterns</a> (a.k.a Gang of Four)</h3>

<p>This is the all times classic. These four gentlemen were the firsts to formalized and compile all patterns found on Object Oriented Systems. Here my advice is to go one by one, pick a pattern, read it, understand it, implement it and ,finally, really understand it.</p>

<h3><a href="http://www.amazon.com/Head-First-Design-Patterns-Freeman/dp/0596007124">Head First Design Patterns</a></h3>

<p>This one I’ve used when I didn’t understand a concept from the Gang of Four, it is easier to grasp the concepts, the approach is way less hardcore than the original GoF, but it still is a great book.</p>

&nbsp;

<h2>Code Samples</h2>

<p>That said, it’s always good to have examples of each Design Pattern by your side, so you can study the DP and check other examples, so real world examples are perfect for it:</p>

<p><a href="http://stackoverflow.com/questions/1673841/examples-of-gof-design-patterns/2707195#2707195">List with Examples of Patterns implemented in the Java SE and EE API</a></p>

<p><a href="http://www.dofactory.com/net/design-patterns">List with Examples of patterns demonstrated with C#</a></p>

<p><a href="http://sourcemaking.com/design_patterns">Excellent examples and explanations of each Design Pattern</a></p>

<p><a href="http://c2.com/cgi/wiki?PeopleProjectsAndPatterns">Another great material on Design Patterns, with lots of great thoughts on it</a></p>

<p>I believe this is a good start to learn Design Pattern and I hope this helps someone, mainly if they’re struggling with the same doubts I had when trying to learn it.</p>

<p>Oh, one more thing: <strong>Do not ever go Extreme Go Horse, really.</strong></p>
</html>

</p>
    </li>
    <hr/>
    &nbsp;
  
    <li>
	<h1>
      <a href="/2014/10/31/Thoughts-on-Automata-Theory/">
	
	<div style="line-height:35px;color:#444;">Thoughts on Automata Theory</div>
	
	</a>
	</h1>
	<div style="margin-top:-15px;color:#E11F00;">31 October 2014</div>
        &nbsp;
      <p><html>
<p>I’ve been reading many texts on automata theory these times, and let me tell you, that’s such a wonderful thing. It pretty much explain how computers can…. compute! Simply put, Automata Theory deals with the logic of computation with respect to simple machines, referred to as Automata.<p>

<p>From the mathematical models to represent it to the fun programming implementations, it’s really great and exciting to study it!</p>

<p>Automatons are abstract models of machines that perform computations on an input by moving through a series of states or configurations. At each state of the computation, a transition function determines the next configuration on the basis of a finite portion of the present configuration. As a result, once the computation reaches an accepting configuration, it accepts that input. The most general and powerful automata is the <a href="http://en.wikipedia.org/wiki/Turing_machine">Turing machine</a>.</p>

<p>In layman’s terms, FSM <em>(Finite State Machine)</em> or Automaton is a device <em>(hardware or software)</em> that responds to external events and produces actions. The actions generated depend on the past history of the system, i.e. its state.</p>

<p>This can go from a simple reserved word analyzer</p>

<img src="/images/thenautomata2.png" width=300 height=214/>
<p>
To big Regular Expressions:
</p>

<img src="/images/bigdfa.jpg" width=700 height=400 />

<p>Automatons are also essentials to understand the <strong>limits of the computation</strong>, thus, we have now two important problems coming out from this thought:</p>
<p>
1. What computers can do?
</p>
<p>
2. What computers can do efficiently?
</p>
<p>
The first one is called <a href="http://courses.cs.washington.edu/courses/cse322/08sp/lec20.pdf">Decidability</a> and the second one is called <a href="http://en.wikipedia.org/wiki/Computers_and_Intractability">intractability</a>
</p>

<p>And it brings our minds to the very beginning of the Computing Science, where many scientist were thinking about the limits of computation, not that today there aren’t many scientists working on it, but today many programmers, sadly, ignore this kind of knowledge.</p>

<p>But, returning to our automatons, they’re represented by a bunch of states that we represent formally as \( Q \), a finite set of symbols ( \( \sum \) ), a transition function ( \( \delta \) ) that has two parameters: a state \( Q \) and a symbol, this function is responsible for the change of states in the automaton. An initial State from \( Q \) and a acceptance state also from \( Q \).</p>

<p>So we can say that a generic automaton can be represented formally as</p>
<span style="font-size:169%">
$$
A = \left ( Q, \sum, \delta, q0, F  \right )
$$
</span>
&nbsp;
<p>The automatons fall into two classifications, they can be:</p>
&nbsp;
<h3>Deterministic</h3>

<p>Where they can’t be at more than one state at the same time, it’s the real world way to represent abstracts machines, because this kind of automaton has no ambiguity . Here’s a simple example of an DFA <em>(Deterministic Finite Automaton)</em> that only accepts string having 001 as substring.</p>
<div style="margin-top:-15px;">
<img src="/images/dfaex1.png" />
</div>

<p>Informally speaking, if you put a string of 0s and 1s such as 10011 and process it number by number, following the states changes you will see that it will end the processing and your current state will be the acceptance state, so, this string is acceptable! So a string such as 11101010, if you try the same process, won’t end at an acceptable state, so we say that this string is not acceptable by this automaton.</p>

&nbsp;

<h3>Non Deterministic</h3>

<p>In this case, the automaton can change to multiple states at the same time, which means, it’s not so deterministic and precise as the deterministic automaton. So why one would use this non deterministic automaton? Simply put, it’s way easier to design a NFA (Non deterministic Finite Automaton) to solve a determined problem than to design a precise DFA to solve this same problem.</p>

<p><strong>But! We’ve a problem here!</strong></p>

<p> <em> How can a computer, which is an unambiguous machine, process something that is not deterministic? </em></p>

<p><strong>It can’t. And it won’t!</strong></p>
<div style="text-align:center;">
<img src="/images/pergunta.jpg"/>
</div>
<p><em>So why in the seven hells would i want to use this NFA if the machine can’t understand?</em></p>

<p>The answer is, every NFA has an equivalent DFA, which means, if a language is recognized by the NFA and by the DFA, they’re equivalent. All you have to do is <a href="http://web.cecs.pdx.edu/~harry/compilers/slides/LexicalPart3.pdf">translate</a> the NFA into a DFA so the machine can use it!</p>

<h3>Talking about Language, what is it in this context?</h3>

<p>Well, this is what we call <strong>Regular Language</strong> which is a Language L accepted by an Automaton, <strong>so the language of an Automaton is the set of all string that it accepts.</strong></p>
<p>We can define the language of a DFA as</p>
<span style="font-size:160%">
$$
L(A) = \{ \omega \,|\, \delta(q0, \omega)\, is\, in\, F \}
$$
</span>

<p>Which means, an Automaton processing a string, from its initial state, being computed by its transition function, if the processing ends in the acceptance state, this means that this is the language of this DFA.</p>
&nbsp;
<h2>Conclusion, next steps and further readings</h2>

<p>As you may have noticed, there are unimaginable ways to use Automatons, it wasn’t even created to apply directly in the Computer Science, two neurophysiologists, were the first to present a description of finite Automata in 1943. Their paper, entitled, “A Logical Calculus Immanent in Nervous Activity”, had a huge impact in the computer science.</p>

<p>For anyone who’s trying to dive deeper in this field, I strongly advice the <a href="http://www.amazon.com/Introduction-Automata-Languages-Computation-Edition/dp/0321455363">Ullman’s book on Automata and Complexity Theory</a></p>


<p>And soon I pretend to write few more thing on Automata, such as techniques to translate a NFA to a DFA using the algorithm of subset construction.</p>

<p>For now my main goal was to simply introduce this beautiful branch of the Computer Science and Mathematics and show its applications.</p>

<p>If something isn’t clear to you, drop me an email and let’s talk about it! :)</p>


</html>

</p>
    </li>
    <hr/>
    &nbsp;
  
    <li>
	<h1>
      <a href="/2014/10/10/Fun-with-graphs-pt1/">
	
	<div style="line-height:35px;color:#444;">Fun with graphs pt1</div>
	
	</a>
	</h1>
	<div style="margin-top:-15px;color:#E11F00;">10 October 2014</div>
        &nbsp;
      <p><html>

<p>Graph Theory is definitely one of my favorite branches of the Mathematics & Computer Science, mostly because of its nearest infinity applications, in both real world problems and pure theoretical problems.</p>

<p>These days I’ve been working (with my buddy Daniel Almeida) in a framework to create and manipulate graphs. Which means, creating a data structure to represent graphs, edges, vertexes and creating algorithms to work on this structure. All this is being made with Java and I’ll expose this code here, as I saw a terrible lack of good readable codes about it on the internet.</p>

<p>So, before we start coding the graph’s structure… we must clarify what a graph is and why it’s so important to the Computer Science (and many other sciences).</p>

<p>
A graph is a ordered pair \(G = (V,E)\) , where \(V\) is a set of Vertices/Nodes and \(E\) is a set of Edges, an extremely mple example of a complete <a href="http://mathworld.wolfram.com/SimpleGraph.html">simple</a>, <a href="http://mathworld.wolfram.com/ConnectedGraph.html">connected</a> and <a href="http://mathworld.wolfram.com/CompleteGraph.html">complete</a> graph is:</p>
<div align="middle">
<img src="/images/graph1.png" width=119 height=259/>

<p><em>So, what’s the huge deal with this graph theory thing?</em></p>
</div>

<p>Well, not only theoretical computer science problems lay on the graph theory but also in many other distinct fields, from particle physics, chemistry to <a href="http://en.wikipedia.org/wiki/Mathematical_sociology">sociology</a>.</p>

<p>All this because every little thing in our universe is linked, and when this set of things became a “web of things”, we need to study its properties. And that’s where graph theory get in.</p>

<p>So when a graph gets bigger, we need to represent this structure in a computational way, so we can compute things like shortest path between two nodes, connectivity and thousand of other properties and techniques.</p>

<p>The most common ways to represent graph mathematically are:</p>
&nbsp;
<h2>Adjacency Matrix</h2>

<p>It’s a matrix that represent the adjacency of every node in a graph, it’s an excellent way to work computationally with graphs. The same graph that I presented previously in a visual way can be represented by the following adjacency matrix:</p>
<p>$$ 
\begin{bmatrix}
0 & 1 & 1\\ 
1 & 0 & 1\\ 
1 & 1 & 0
\end{bmatrix}
$$ 
</p>
&nbsp;
<h2>Adjacency List</h2>

<p>This is another common way to represent graph mathematically, it’s a simple list of lists, each node in the main list points to a list of their adjacent nodes.</p>

<p>Here’s an example:</p>
<img src="/images/graph2.png" width=119 height=259/>
<img src="/images/adjaceny-list.gif" style="padding-left:50px; padding-bottom:50px;" width=272 height=132/>

&nbsp;
&nbsp;
&nbsp;

<h2>Data Structures to represent Graphs</h2>

<p>Ok, so, how do we represent graphs, edges and vertexes in terms of data structures? Before we dig deeper in the algorithms and the mathematical properties of the graphs, we need to create our Data Structure to work with.</p>

<h3>The vertex</h3>

<pre>
<code class="java hljs">
package GraphModels;

public class Vertex {
    /* This Data Structure will be capable to represent a Vertex,
    * which is a Node that will be used on a graph
    */
    
    public String id;
    public String name;
    public boolean visited = false;
    
    public Vertex(String id, String name) {
        this.id = id;
        this.name = name;
    }
    public String getId() {
        return id;
    }
    
    public String getName() {
        return name;
    }
    
  @Override
  public String toString() {
    return name;
  }
    
}

</code>
</pre>

<p>For now you may be asking yourself why do we need a variable called “Visited”. Well, we’ll be using it in algorithms to walk through the graph, so we must need to know which nodes were visited. It will became more clear soon!</p>

&nbsp;

<h3>The Edge</h3>

<p>Yes, the edge must be represented computationally! That’s our way to figure out paths through the vertexes, the edge may or may not have a weight, the edge must know its source vertex and its destination vertex</p>

<pre>
<code>
package GraphModels;

public class Edge {
    
     /* This Data Structure will be capable to represent a Edge,
    *    that will be used on a graph
    */
    
    public String id;
    public Vertex source;
    public Vertex destination;
    private final int weight;
    
    public Edge(String id, Vertex source, Vertex destination, int weight) {
        this.id = id;
        this.source = source;
        this.destination = destination;
        this.weight = weight;
    }
    
    public String getId() {
        return id;
    }
    public Vertex getDestination() {
        return destination;
    }
    
    public Vertex getSource() {
        return source;
    }
    public int getWeight() {
        return weight;
    }
    
    @Override
    public String toString() {
        return source + " " + destination;
    }
} 
</code>
</pre>

&nbsp;

<h3>The Graph</h3>

<p>That’s for sure the biggest and most complex part, don’t panic with the many algorithms already implemented in this code. I’ll be explaining one by one.</p>

<p>We’re reading a text file containing the text file, if you want to test by yourself, make sure to create a .txt in the correct way and to pass the correct file path! You can find the instructions to write the .txt graph in the comments of this code</p>


<pre>
<code class="java hljs">

package GraphModels;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;

public class Graph {
    
    /* This Data Structure will be capable to represent a Graph,
    *   where G = (V, E)
    */
    
   private  List<Vertex> nodes;
   private  List<Edge> edges;
   public Vertex node;
   public Edge edge;
   private String path;
   private int [][] adjacencyMatrix;
   private Map nodesMatrixMap;
   private List<Vertex> adjacentNodes;
   public int degree;
   public int minDegree;
   public int maxDegree;
   public int avgDegree;
   

   public Graph() {
    
  }


  public List<Vertex> getNodes() {
    return nodes;
  }

  public List<Edge> getEdges() {
    return edges;
  }
  
  public void setNodes(List<Vertex> vertex){
      this.nodes = vertex;
  }
  
  public void setEdges(List<Edge> edges){
      this.edges = edges;
  }
  
  // Find an edge
  // TO-DO: Change == to equals
  public Edge getEdge(Vertex source, Vertex destination) {
      for (Edge edge : this.getEdges()) {
          if ((edge.getSource().getId() == source.getId() && edge.getDestination().getId() == destination.getId()) || (edge.getSource().getId() == destination.getId() && edge.getDestination().getId() == source.getId())) {
              return edge;
          }
      }
      return null;
  }
 
  // Check if there is an edge for two given vertices
  public boolean hasEdge(Vertex source, Vertex destination) {
      Edge result = this.getEdge(source, destination);
      if (result != null) {
        return true;
      } else {
        return false;
      }
  }
  
  public List<Vertex> getAdjacentNodes(Vertex node){
      adjacentNodes = new ArrayList<Vertex>();
      
      for (Vertex currentNode : nodes){
          if (hasEdge(node, currentNode)){
              adjacentNodes.add(currentNode);
          }
      }
       
      return adjacentNodes;
  }
  
  public int getMinDegree(){
      minDegree = 99999999;
      
      for (Vertex node : nodes){
          if (this.getDegree(node)<minDegree){
              minDegree = this.getDegree(node);
          }
      }
      
      
      return minDegree;
  }
  public int getMaxDegree(){
      maxDegree = 0;
      
      for (Vertex node : nodes){
          if (this.getDegree(node)>maxDegree){
              maxDegree = this.getDegree(node);
          }
      }

      return maxDegree;
  }
  public int getAvgDegree(){
      avgDegree = 0;
      
      for (Vertex node : nodes){
          avgDegree += this.getDegree(node);
      }
      avgDegree = avgDegree/nodes.size();
      
      return avgDegree;
  }
  
 
  //modified for our needs   
  public int breadthFirstSearch(Vertex rootNode){
      
      int visitedNodes = 0;
      Queue q = new LinkedList();
      q.add(rootNode);

      while (!q.isEmpty()){
          Vertex currentNode = (Vertex) q.peek();
          for (Vertex node : this.getAdjacentNodes(currentNode)){
              if (!node.visited){   
                  node.visited = true;
                  q.add(node);
                  visitedNodes++;
              }
          }
          q.remove();   
      }
      //reseting all flags
      for (Vertex node : nodes){
          node.visited = false;
      }

      return visitedNodes;
    
  }
  
  public boolean isConnected(){
      int numberOfNodes = nodes.size();
      
      for (Vertex node : nodes){
          if (!(this.breadthFirstSearch(node) == numberOfNodes)){
              return false;
          }
      }
      return true;
  }
  
  //TO-DO: error treatment. 
  // while this treatment doesn't exist: BE EXTREMELY CAREFUL WITH GRAPH.TXT
  // the right syntax is:
  //line (1) :1,2,...,n 
  //line (2) :1-2
  //line (3) : weight of the previous connection
  //line (n) :2-n
  //line (n+1) : weight of the previous connection
  //line (n+2) :-1
  //where the first line you must declare the nodes, each one separated by comma
  //the second til the n-th line you must declare the connections between the nodes declared 
  //in the first line
  //after every connection, in the next line, you must declare the weight of the connection
  // leave everything zero to create a unweighted graph
  //after the last connection, you must end with a -1
  // if you don't do this your computer may explode lol
  //...
  //...
  //...
  // i don't know, i did never try that.
  public void createGraph(String path) throws FileNotFoundException, IOException{
      this.path = path;
      
      nodes = new ArrayList<Vertex>();
      edges = new ArrayList<Edge>();
            
      FileReader fr = new FileReader(path);
      BufferedReader textReader = new BufferedReader(fr);
     
      //gets the first line, which are the nodes that must be created
      String TextData = textReader.readLine();
      
      //separate the string with numbers
      String[] nodesInString = TextData.split("\\s*,\\s*");
      
      //create the list of nodes
      for (String nodeInString : nodesInString){

          node = new Vertex(nodeInString, "node " + nodeInString);
          nodes.add(node);
          
      }
      
      //create the list of edges
      String edgeIntoString;
      Vertex vertex_aux1 = new Vertex("-1","-1");
      Vertex vertex_aux2 = new Vertex("-1","-1");;
      int n = 0;
      //varre a linha que tem x-y
      while (!(edgeIntoString = textReader.readLine()).equals("-1")){
          
          String[] nodesConnected = edgeIntoString.split("\\s*-\\s*");
          //varre os dois nodes
         
          int peso = Integer.parseInt(textReader.readLine());
              
              //verifica se x e y passados no txt estão instanciados em nodes 
              for (Vertex node : nodes){
         
                  if (nodesConnected[0].equals(node.getId())){
                      //se o node do txt foi achado em nodes
                      
                      vertex_aux1 = new Vertex(node.getId(), node.getName());
                  }
              }
              for (Vertex node : nodes){
         
                  if (nodesConnected[1].equals(node.getId())){
                     
                      
                      vertex_aux2 = new Vertex(node.getId(), node.getName());
                  }
              }
              
              
          edge = new Edge(Integer.toString(n),vertex_aux1, vertex_aux2, peso);
          edges.add(edge);
      }
      
      
      
  }
  // Add a new edge
  public boolean addEdge(Vertex source, Vertex destination) {
      Edge newEdge = new Edge("id", source, destination, 0);
      return this.edges.add(newEdge);
  }
  
  // Remove an edge
  public boolean removeEdge(Vertex source, Vertex destination) {
    
      Edge result = this.getEdge(source, destination);
      
      if (result != null) {
          return this.edges.remove(result);
      } else {
          System.out.println("Couldn't find edge");
          return false;
      }
  }
  
  public int getDegree(Vertex node){
      
      degree = 0;
      
      for (Vertex CurrentNode : nodes){
          if (hasEdge(node, CurrentNode)){
              degree++;
          }
      }
  
      return degree;
  }
  
  public void printGraph() {
   
      for (Vertex node: this.getNodes()){
          System.out.println(node.getName());
          System.out.print("Adjacent nodes: ");
          adjacentNodes = getAdjacentNodes(node);
          for (Vertex adjacentNode : adjacentNodes){
              System.out.print(adjacentNode.getName() + " ");
          }

          System.out.println(" ");
          System.out.println("Degree of this node: " + getDegree(node));
          System.out.println(" "); 
      }
      System.out.println("- - - - - - - - - - - - - - - - ");
      System.out.println(" ");
      System.out.println("Min Degree of this Graph: " + getMinDegree());
      System.out.println(" ");
      System.out.println("Max Degree of this Graph: " + getMaxDegree());
      System.out.println(" ");
      System.out.println("Average Degree of this Graph: " + getAvgDegree());
      System.out.println(" ");
      System.out.println("Graph is connected: " + this.isConnected());
      System.out.println(" ");
      System.out.println("- - - - - - - - - - - - - - - - ");
      System.out.println("Connections: ");
      System.out.println(" ");
      for (Edge edge : this.getEdges() ){
          System.out.print(edge.getSource().getId() +"<->"+edge.getDestination().getId()+" ");
          System.out.println("weight: " + edge.getWeight());
      }
      System.out.println(" ");
      System.out.println("- - - - - - - - - - - - - - - - ");
    }
  
  public void setAdjacencyMatrix() {
    
    initializeAdjacencyMatrix();
    int weigth;
    int source;
    int destination;
    for (Edge currentEdge : this.getEdges() ){
        weigth = currentEdge.getWeight();
        source = (int) nodesMatrixMap.get(currentEdge.getSource().getName());
        destination = (int) nodesMatrixMap.get(currentEdge.getDestination().getName());

        adjacencyMatrix[source][destination] = weigth; 
        //must be symmetric
        adjacencyMatrix[destination][source] = weigth; 
    }
  }
  
  public void initializeAdjacencyMatrix(){
      int numNodes = this.nodes.size();
      adjacencyMatrix = new int[numNodes][numNodes];
      nodesMatrixMap = new HashMap();
      for (int i = 0; i < numNodes; i++) {
          nodesMatrixMap.put(this.nodes.get(i).getName(), i);
          for (int j = 0; j < numNodes; j++) {
              adjacencyMatrix[i][j] = -1;
          }
      }
  }
  
  public void printAdjacencyMatrix() {
    
      String sourceName;
      String destName;
      int source;
      int dest;
      
      System.out.println(" ");
      System.out.println("Adjacency Matrix: ");
      System.out.println(" ");
      
      for (int i = 0; i < this.nodes.size(); i++) {
          sourceName = this.nodes.get(i).getName();
          source = (int) nodesMatrixMap.get(sourceName);
          for (int j = 0; j < this.nodes.size(); j++) {
              destName = this.nodes.get(j).getName();
              dest = (int) nodesMatrixMap.get(destName);
              if (adjacencyMatrix[source][dest] == -1) {
                  System.out.print("- ");
              } else {
                  System.out.print(adjacencyMatrix[source][dest] + " ");
              }
          }
          System.out.print("\n");
      }
  }
  
}

</code>
</pre>

&nbsp;

<h3>The test file</h3>

<p>Here’s the file containing the main, if you want to test, remember to change the path file!</p>

<pre>
<code class="java hljs">
package graphproject;
import GraphModels.*;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

public class GraphProject {
    
    //graph creation procedure
    private List<Vertex> nodes;
    private List<Edge> edges;
    private Graph graph;
    public Vertex node;
    public Edge edge;
    
    public void printGraph(Graph graph) {
      for (Vertex node: graph.getNodes()){
             System.out.println(node.toString());
      }
      
      for (Edge edge : graph.getEdges() ){
             System.out.println(edge.toString());
             System.out.println(" ");
      }
      
    }
    
    public void test() throws IOException{
        
        Graph graph = new Graph();
        graph.createGraph("/Users/daniel/Documents/workspace_java/GraphProject/src/graphproject/graph.txt");
        
        graph.printGraph();
        graph.setAdjacencyMatrix();
        graph.printAdjacencyMatrix();
    }
    //end of graph creation procedure
 
    public static void main(String[] args) throws IOException {
       GraphProject gp = new GraphProject();
       
       gp.test();
    }
}

</code>
</pre>
&nbsp;

<h2>Conclusion and next steps</h2>

<p>At this moment, you’re perfectly able to create a graph (via .txt file) and run all those algorithms to extract information about your graph. Just make sure to import the right libraries and to put the files in the right package. Doing these little things right, I’m pretty sure this will work perfectly.</p>

<p>But I’m sure you may be a little lost about a few algorithms and techniques we’ve implemented in the Graph.java. But, don’t worry, i’ll be explaining each method one by one in the next parts of this post!</p>

</html>


</p>
    </li>
    <hr/>
    &nbsp;
  
  &nbsp;
  &nbsp;
  &nbsp;
        <div style="width:95%;display:block-inline;font-size:20px; margin-left:12px;">
                

                <div style="font-family:'proregular';float:left;"><a href="/blog/"> Recent Posts </a></div>
                
                

                <div style="font-family:'proregular';float:right;"><a href="/blog/page3/">Older Posts -></a></div>
                


        </div>
</ul>


  </div>


<!-- InstanceEndEditable --><!-- InstanceBeginEditable name="subNav" --><!-- InstanceEndEditable --><!-- InstanceBeginEditable name="mainContent" --><!-- InstanceEndEditable -->
  <!-- This clearing element should immediately follow the #mainContent div in order to force the #container div to contain all child floats -->
  <br class="clearfloat" />
  <!-- InstanceBeginEditable name="footer" -->
  <div id="footer">
    <!-- end #footer -->
    </div>
  <!-- InstanceEndEditable -->
  <!-- end #container --></div>
    

</body>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<script>


var fixmeTop = $('#sidebar').offset().top;       // get initial position of the element

$(window).scroll(function() {                  // assign scroll event listener

    var currentScroll = $(window).scrollTop(); // get current position

    if (currentScroll + 20 >= fixmeTop) {           // apply position: fixed if you
        $('#sidebar').css({                      // scroll to that element or below it
            position: 'fixed',
            top: '0',
	    'margin-top':'0px',
            'left': '200'
        });
    } else {                                   // apply position: static
        $('#sidebar').css({                      // if you scroll above it
            position: 'static',
            'margin-top': '0px',
            'left':'200px'
        });
    }

});


$(document).ready(function(){
    // to fade in on page load
   $("#mainContent").fadeIn(1500).removeClass("hidden");
   $('a').click(function(e){
        redirect = $(this).attr('href');
        e.preventDefault();
        $('#mainContent').fadeOut(500, function(){
            document.location.href = redirect
        });
    });
})

</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-38327934-3', 'auto');
  ga('send', 'pageview');

</script>
<!-- InstanceEnd --></html>
